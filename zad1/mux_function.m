function [Y,Xf,Af] = mux_function(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 09-May-2019 20:13:27.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 3xQ matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0;0;0];
x1_step1.gain = [2;2;2];
x1_step1.ymin = -1;

% Layer 1
b1 = [-2.964625163702979016;1.5869251256763208247;1.6418736527126989166;1.0803301553072957031;-1.1380591654265044266;-0.13356512934191558384;0.93291086712207282883;1.6718910811932883309;2.2609362598491080654;-3.2720869015214888442];
IW1_1 = [1.00847395015606911 2.9108943642520790362 0.36820852421000094257;-2.5988929492387407016 1.5335385883573082744 -1.8059292592595439508;-1.3123293626448417903 -2.7285290989114030502 -0.40954185846382284986;-2.6820269054057184199 -0.60947365379686613274 -1.2426615461616408176;1.2184659996497382295 -0.45574707475742909368 -2.8166271784884102658;-0.91306468141433028141 2.8982068253778385802 -0.5543140384505796936;1.9589628680069184341 -2.2667899186451903049 -0.52075280644013599574;2.5986185200393974171 1.3899492903146801748 1.0475441648134793393;1.8002657368227652501 0.90332424719741910568 2.2386404277890719072;-2.3448224917261577538 0.76779257684131774209 1.442918204618990119];

% Layer 2
b2 = 1.0137674717068154706;
LW2_1 = [0.49871280220672375982 -0.84986096878785133413 -0.60670791593720208024 0.67458365989920099359 0.79603662916146977757 0.01114016893987301339 0.0094286366071065809413 0.25568847672472883037 0.23970393458751568239 0.81877198651718341438];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 2;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
